#!/usr/bin/env ts-node -T -r tsconfig-paths/register
import fs from 'fs';
import path from 'path';

import { type Action, RoleEnum } from 'shared/logic/types';
import Game from 'shared/logic/Game';

import WorkingClassRole from '../shared/logic/roles/WorkingClassRole';
import MiddleClassRole from '../shared/logic/roles/MiddleClassRole';
import CapitalistRole from '../shared/logic/roles/CapitalistRole';
import StateRole from '../shared/logic/roles/StateRole';

const rootDir = path.join(__dirname, '..');
const sharedDir = path.join(rootDir, 'shared');
const targetFile = path.join(sharedDir, 'logic/types.generated.ts');

const game = new Game({} as any);

const todo = (
    [
        ['game', 'actions', game],
        [RoleEnum.workingClass, 'basicActions', new WorkingClassRole(game)],
        [RoleEnum.workingClass, 'freeActions', new WorkingClassRole(game)],
        [RoleEnum.middleClass, 'basicActions', new MiddleClassRole(game)],
        [RoleEnum.middleClass, 'freeActions', new MiddleClassRole(game)],
        [RoleEnum.capitalist, 'basicActions', new CapitalistRole(game)],
        [RoleEnum.capitalist, 'freeActions', new CapitalistRole(game)],
        [RoleEnum.state, 'basicActions', new StateRole(game)],
        [RoleEnum.state, 'freeActions', new StateRole(game)],
    ] as const
)
    .map(([ns1, ns2, target]) => {
        return Object.entries((target as any)[ns2]).map(([key, action]) => {
            const typeValue = target.constructor.name + `['${ns2}']['${key}']`;
            const type = `${ns1}:${key}`;
            return { typeValue, ns1, ns2, type, action: action as any } satisfies {
                type: string;
                typeValue: string;
                ns1: string;
                ns2: string;
                action: Action;
            };
        });
    })
    .flat();

function init() {
    const content: string[] = [
        '// ‼️ Generated via scripts/generate-shared-types.ts. Do not edit this file manually.',
        '',
        "import { z } from 'zod';",
        '',
        "import { type ActionEventFromAction } from './types';",
        '',
        "import type Game from './Game';",
        "import type WorkingClassRole from './roles/WorkingClassRole';",
        "import type MiddleClassRole from './roles/MiddleClassRole';",
        "import type CapitalistRole from './roles/CapitalistRole';",
        "import type StateRole from './roles/StateRole';",
        '',
        'export type AnyActionEvent = ActionEventMap[keyof ActionEventMap];',
        '',
        'export type ActionEventName = keyof ActionEventMap;',
        '',
        'export const actionEventNameSchema = z.enum([',
        ...todo.map(({ type }) => tab1 + quote(type) + ','),
        '] as const);',
        '',
        'export type ActionEventMap = {',
        ...createActionEventMap(),
        '};',
        '',
        '/** mostly used in testing */',
        'export type PlayerInput = {',
        ...createPlayerInputDataMap(),
        '};',
        '',
    ];

    fs.writeFileSync(targetFile, content.join('\n'));
}

const tab1 = '    '.repeat(1);
const tab2 = '    '.repeat(2);
const quote = (s: any) => `'${s}'`;

function createActionEventMap() {
    const result: string[] = [];
    for (const { type, typeValue } of todo) {
        result.push(
            splitIfNeeded([
                `'${type}': ActionEventFromAction<`,
                `'${type}',`,
                ' ' + typeValue,
                '>;',
            ]),
        );
    }
    return result;
}

function createPlayerInputDataMap() {
    const result: string[] = [];
    for (const { type, action, typeValue } of todo) {
        if (!action.playerInputSchema) continue;
        result.push(
            splitIfNeeded([
                `'${type}': z.infer<`,
                `NonNullable<${typeValue}['playerInputSchema']>`,
                '>;',
            ]),
        );
    }
    return result;
}

const splitIfNeeded = (chunks: string[]) => {
    const oneLine = chunks.join('');
    if (oneLine.length <= 96) return tab1 + oneLine;
    return [
        tab1 + chunks[0],
        ...chunks.slice(1, -1).map(c => tab2 + c.trim()),
        tab1 + chunks[chunks.length - 1],
    ].join('\n');
};

init();
